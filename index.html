<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Terminal Chatroom</title>
  <style>
    :root {
      --bg: #0b0e0c;
      --panel: #111511;
      --text: #c8facc;
      --muted: #7ecf87;
      --error: #ff6b6b;
      --warn: #ffd166;
      --accent: #3ad13a;
      --border: #1d2a1f;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 16px; background: var(--bg); color: var(--text);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    .wrap { max-width: 980px; margin: 0 auto; display: grid; gap: 12px; }
    header { display:flex; gap:12px; align-items:center; justify-content:space-between; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .pill { padding:6px 10px; border:1px solid var(--border); background: var(--panel); border-radius: 999px; color: var(--muted); }
    .btn { cursor:pointer; border:1px solid var(--border); background: var(--panel); color: var(--text); border-radius:10px; padding:6px 10px; }
    .btn:disabled { opacity: .5; cursor:not-allowed; }
    .danger { color: var(--error); border-color:#442222; }

    #log {
      background: #0d120e; border: 1px solid var(--border); border-radius: 12px; padding: 10px; height: 420px; overflow-y: auto;
      white-space: pre-wrap; line-height: 1.35; box-shadow: 0 0 0 1px #0c140e inset;
    }
    .line { display:block; padding: 2px 0; }
    .sys { color: var(--muted); }
    .err { color: var(--error); }
    .warn { color: var(--warn); }
    .me { color: #9adfff; }
    .msg { color: var(--text); }
    .dim { opacity: .7; }

    .composer { display:grid; grid-template-columns: 1fr auto; gap:8px; }
    .input { width: 100%; padding:10px; border-radius:10px; border:1px solid var(--border); background: var(--panel); color: var(--text); }
    .toolbar { display:flex; gap:8px; align-items:center; }
    .filelist { display:flex; gap:6px; flex-wrap:wrap; }
    .filepill { border:1px solid var(--border); background:#0e1511; padding:4px 8px; border-radius:999px; font-size:12px; }
    a.dl { color:#c7e9ff; text-decoration: underline; cursor:pointer; }

    .legend { font-size: 12px; color: var(--muted); }
    .sectionTitle { color:#a1f0a8; margin: 8px 0 4px; }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="row">
      <div class="pill" id="status">booting…</div>
      <div class="pill" id="chan">channel: —</div>
      <div class="pill" id="user">user: —</div>
    </div>
    <div class="row">
      <button id="clearLog" class="btn">Clear log</button>
      <button id="reconnect" class="btn">Reconnect</button>
    </div>
  </header>

  <div class="sectionTitle">[history]</div>
  <div id="log"></div>

  <div class="composer">
    <input id="text" class="input" placeholder="type a message, Enter to send" autocomplete="off" />
    <div class="toolbar">
      <input id="file" type="file" multiple />
      <button id="send" class="btn">Send</button>
    </div>
  </div>
  <div class="legend">Files are sent as base64. Messages throttle at 1 msg/sec. Pending messages remain until echoed by websocket. 429 keeps pending.</div>
  <div class="filelist" id="queuedFiles"></div>
</div>

<script type="module">
  // ---------- helpers ----------
  const $ = (s)=>document.querySelector(s);
  const logEl = $('#log');
  const statusEl = $('#status');
  const chanEl = $('#chan');
  const userEl = $('#user');
  const textEl = $('#text');
  const sendBtn = $('#send');
  const fileInp = $('#file');
  const queuedFilesEl = $('#queuedFiles');
  const clearBtn = $('#clearLog');
  const reconnectBtn = $('#reconnect');

  const ui = {
    line(msg, cls='msg'){
      const d = document.createElement('div');
      d.className = `line ${cls}`;
      d.textContent = msg;
      logEl.appendChild(d);
      logEl.scrollTop = logEl.scrollHeight;
      return d;
    },
    sys(msg){ return this.line(`[system] ${msg}`, 'sys'); },
    err(msg){ return this.line(`[error] ${msg}`, 'err'); },
    warn(msg){ return this.line(`[warn] ${msg}`, 'warn'); },
    me(msg){ return this.line(`[me] ${msg}`, 'me'); },
    msg(username, content){ return this.line(`${username}: ${content}`, 'msg'); },
    fileBadge({name,size}){
      const span = document.createElement('span');
      span.className = 'filepill';
      span.textContent = `${name} (${formatSize(size)})`;
      return span;
    }
  };

  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  const formatSize = (n)=>{
    if (n==null) return '?';
    const u=['B','KB','MB','GB']; let i=0; while(n>=1024 && i<u.length-1){n/=1024;i++;}
    return `${n.toFixed( (i?1:0) )} ${u[i]}`;
  };

  async function fileToBase64(file){
    const buf = await file.arrayBuffer();
    const b64 = btoa(String.fromCharCode(...new Uint8Array(buf)));
    return `data:${file.type||'application/octet-stream'};base64,${b64}`;
  }

  function hashContent(str){
    // cheap content hash for optimistic matching
    let h = 2166136261 >>> 0;
    for (let i=0;i<str.length;i++){ h ^= str.charCodeAt(i); h = Math.imul(h, 16777619); }
    return (h>>>0).toString(16);
  }

  // ---------- state ----------
  let auth = null; // { user_id, baseurl, subpart }
  let client = null; // XanoClient
  let channel = null; // channel instance
  let channelName = 'main';
  let realtimeHash = null;
  let sendingCooldown = false; // throttle 1 msg/sec
  const pending = new Map(); // tempId -> {el, user_id, contentHash}
  const seenMsgIds = new Set(); // dedupe
  let historyCursor = null; // __msg_id to paginate older

  // endpoints (server provided by you)
  function epHistory(){
    return `${auth.baseurl}/${auth.subpart}/chat/history?channel=${encodeURIComponent(channelName)}&limit=50${historyCursor?`&before=${encodeURIComponent(historyCursor)}`:''}`;
  }
  function epSend(){
    return `${auth.baseurl}/${auth.subpart}/chat/send`;
  }

  // ---------- bootstrap ----------
  async function boot(){
    try{
      status('booting');

      // parse auth from ?auth=base64
      const params = new URLSearchParams(location.search);
      const authParam = params.get('auth');
      if (!authParam) throw new Error('No auth parameter');
      auth = JSON.parse(atob(authParam));
      if (!auth.user_id || !auth.baseurl || !auth.subpart) throw new Error('Invalid auth payload');
      userEl.textContent = `user: ${auth.user_id}`;

      // do auth request
      const authUrl = `${auth.baseurl}/${auth.subpart}/auth?user_id=${encodeURIComponent(auth.user_id)}`;
      ui.sys(`authenticating…`);
      const res = await fetch(authUrl);
      const data = await res.json();
      if (data.info_code !== 200) {
        if (data.info_code === 429) throw new Error(`Banned: ${data.msg}`);
        throw new Error(data.msg||'Auth failed');
      }

      // obtain ws script + ws info
      const wsScript = (data.script||[]).find(s=>s.type==='xano_websocket');
      const wsInfo = data.websocket || data; // supports either format
      realtimeHash = wsInfo.hash;
      channelName = wsInfo.name || 'main';
      chanEl.textContent = `channel: ${channelName}`;

      // load the websocket client bundle (data: URL base64)
      if (!wsScript?.url) throw new Error('Missing websocket script URL');
      ui.sys('loading websocket client…');
      await import(wsScript.url);

      // connect
      ui.sys('connecting websocket…');
      // XanoClient is exposed globally by the loaded script
      client = new XanoClient({ instanceBaseUrl: auth.baseurl, realtimeConnectionHash: realtimeHash });
      channel = client.channel(channelName);

      // handlers
      channel.on(handleEvent);

      // join (ask server to include history if it wants)
      channel.join?.({ history: true, presence: false }).catch(()=>{});

      status('connected');
      ui.sys('connected');

      // initial history fetch from HTTP endpoint you provide
      await fetchAndRenderHistory();

    }catch(err){
      status('error');
      ui.err(err.message||String(err));
    }
  }

  function status(s){
    const map = { connected: ['✅ Connected', 'var(--accent)'], booting: ['⏳ Booting', 'var(--muted)'], error: ['❌ Error', 'var(--error)'] };
    const [label,color] = map[s] || [s, 'var(--muted)'];
    statusEl.textContent = label; statusEl.style.color = `var(--text)`; statusEl.style.borderColor = 'var(--border)';
    statusEl.style.color = color;
  }

  // ---------- history ----------
  async function fetchAndRenderHistory(){
    try{
      const url = epHistory();
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error(`history ${r.status}`);
      const j = await r.json();
      const msgs = j.messages||[];
      if (msgs.length) ui.sys(`[history] ${msgs.length} message(s)`);
      // oldest -> newest for display
      msgs.forEach(renderMessage);
      // update cursor to the oldest message id for pagination
      historyCursor = msgs.length ? msgs[0].__msg_id : historyCursor;
    }catch(e){ ui.warn(`history load failed: ${e.message}`); }
  }

  // ---------- websocket events ----------
  function handleEvent(action){
    const data = action?.payload?.data;
    if (!data) return;
    // If server sometimes wraps as array, handle both
    if (Array.isArray(data)) { data.forEach(renderMessage); } else { renderMessage(data); }
  }

  // ---------- render ----------
  function renderMessage(msg){
    // dedupe by __msg_id when present
    if (msg.__msg_id && seenMsgIds.has(msg.__msg_id)) return;

    const username = msg.username || (msg.user_id?.slice(0,8) || 'user');
    let line = `${username}: ${msg.content ?? ''}`;

    // files rendering as [name (size) download]
    if (Array.isArray(msg.files) && msg.files.length){
      const parts = msg.files.map(f=>`[${f.name} (${formatSize(f.size)}) download]`).join(' ');
      line += (msg.content? ' ' : '') + parts;
    }

    const el = ui.msg(username, line.replace(/^.*?:\s/, ''));

    // Convert [name (size) download] into actual links
    if (Array.isArray(msg.files)){
      const anchors = [];
      msg.files.forEach(f=>{
        try{
          const a = document.createElement('a');
          a.className = 'dl';
          a.textContent = `[${f.name} (${formatSize(f.size)}) download]`;
          // create Blob URL from base64
          const base64 = (f.data||'').split(',')[1]||'';
          const bytes = Uint8Array.from(atob(base64), c=>c.charCodeAt(0));
          const blob = new Blob([bytes], { type: f.mime||'application/octet-stream' });
          a.href = URL.createObjectURL(blob);
          a.download = f.name || 'file';
          a.style.marginRight = '6px';
          logEl.appendChild(a);
          anchors.push(a);
        }catch{}
      });
      if (anchors.length) logEl.appendChild(document.createElement('br'));
    }

    if (msg.__msg_id) seenMsgIds.add(msg.__msg_id);

    // match and clear pending if same user + content hash
    const key = [...pending.keys()].find(k=>{
      const p = pending.get(k);
      return p && p.user_id===msg.user_id && p.contentHash===hashContent(msg.content||'');
    });
    if (key){
      const p = pending.get(key);
      if (p?.el) p.el.classList.remove('dim');
      pending.delete(key);
    }
  }

  // ---------- sending ----------
  async function sendMessage(){
    if (sendingCooldown) { ui.warn('slow down (1 msg/sec)'); return; }
    const content = textEl.value.trim();
    if (!content && fileInp.files.length===0) return;

    // prepare files as base64
    const files = [];
    for (const f of fileInp.files){
      const data = await fileToBase64(f);
      files.push({ name: f.name, size: f.size, mime: f.type, data });
    }

    const payload = {
      user_id: auth.user_id,
      channel: channelName,
      content,
      files,
    };

    // optimistic UI
    const tempId = `temp_${Date.now()}_${Math.random().toString(16).slice(2)}`;
    const el = ui.me(content || (files.length? `[${files.length} file(s)]` : '(empty)'));
    el.classList.add('dim');
    pending.set(tempId, { el, user_id: auth.user_id, contentHash: hashContent(content||'') });

    // show queued file badges under composer
    queuedFilesEl.innerHTML = '';

    try{
      sendingCooldown = true; setTimeout(()=>sendingCooldown=false, 1000);
      const r = await fetch(epSend(), { method:'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
      if (r.status === 429){
        // keep pending; wait for websocket echo to confirm
        ui.warn('rate limited (429) — will confirm when echoed');
        return;
      }
      if (!r.ok){
        // on non-OK (besides 429), mark error but keep visible
        el.classList.remove('dim'); el.classList.add('err');
        ui.err(`send failed ${r.status}`);
        return;
      }
      const j = await r.json().catch(()=>({}));
      if (j.__msg_id) seenMsgIds.add(j.__msg_id);
      // we still wait for echo to undim; server echo will clear pending
    }catch(err){
      el.classList.remove('dim'); el.classList.add('err');
      ui.err('network error sending');
    } finally {
      textEl.value=''; fileInp.value='';
    }
  }

  // ---------- UI events ----------
  textEl.addEventListener('keydown', (e)=>{ if (e.key==='Enter') sendMessage(); });
  sendBtn.addEventListener('click', sendMessage);
  clearBtn.addEventListener('click', ()=>{ logEl.innerHTML=''; ui.sys('log cleared'); });
  reconnectBtn.addEventListener('click', ()=>{ location.reload(); });
  fileInp.addEventListener('change', ()=>{
    queuedFilesEl.innerHTML = '';
    for (const f of fileInp.files){ queuedFilesEl.appendChild(ui.fileBadge({name:f.name,size:f.size})); }
  });

  // ---------- start ----------
  boot();
</script>
</body>
</html>
