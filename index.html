<!DOCTYPE html>
<html lang="en">
<head>
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:type" content="website">
<meta content="Terminal Chatrom" property="og:title" />
<meta content="Only shitpost" property="og:description" />
<meta content="https://drmineword.github.io/funterminal/speech-speech-bubble.gif" property="og:image" />
<meta content="#334fff" data-react-helmet="true" name="theme-color" />


    <meta name="twitter:card" content="summary_large_image">
  <title>Terminal Chatroom</title>
  <style>
    :root {
      --bg: #0b0e0c;
      --panel: #111511;
      --text: #c8facc;
      --muted: #7ecf87;
      --error: #ff6b6b;
      --warn: #ffd166;
      --accent: #3ad13a;
      --border: #1d2a1f;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; background: var(--bg); color: var(--text);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      display: flex; flex-direction: column; height: 100vh;
    }
    .wrap { flex: 1; display: flex; flex-direction: column; gap: 8px; padding: 8px; }
    header { display:flex; gap:12px; align-items:center; justify-content:space-between; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .pill { padding:6px 10px; border:1px solid var(--border); background: var(--panel); border-radius: 999px; color: var(--muted); }
    .btn { cursor:pointer; border:1px solid var(--border); background: var(--panel); color: var(--text); border-radius:10px; padding:6px 10px; }
    .btn:disabled { opacity: .5; cursor:not-allowed; }
    .danger { color: var(--error); border-color:#442222; }

      #log {
    background: #0d120e;
    border: 1px solid #1d2a1f;
    border-radius: 12px;
    padding: 10px;
    height: 800px;          /* fixed height */
    max-height: 90vh;       /* responsive cap */
    overflow-y: auto;       /* vertical scroll */
    white-space: pre-wrap;  /* wrap long text */
    word-wrap: break-word;  /* break long words if needed */
    line-height: 1.35;
  }

    .line { padding: 6px 0; }
    .sys { color: var(--muted); }
    .err { color: var(--error); }
    .warn { color: var(--warn); }
    .msg { color: var(--text); display:grid; grid-template-columns:30px auto; gap:6px; align-items:flex-start; }
    .msg img.icon { width:24px; height:24px; border-radius:50%; grid-row: span 2; }
    .msg-header { font-size: 13px; color: var(--muted); }
    .msg-body { margin-top:2px; white-space: pre-wrap; }

    .composer { display:grid; grid-template-columns: 1fr auto; gap:8px; padding-top: 6px; }
    .input {
      width: 100%; padding:10px; border-radius:10px; border:1px solid var(--border);
      background: var(--panel); color: var(--text);
      resize: none; min-height: 40px; overflow-y: hidden;
    }
    .toolbar { display:flex; gap:8px; align-items:center; }
    .filelist { display:flex; gap:6px; flex-wrap:wrap; }
    .filepill { border:1px solid var(--border); background:#0e1511; padding:4px 8px; border-radius:999px; font-size:12px; }
    a.dl { color:#c7e9ff; text-decoration: underline; cursor:pointer; display:inline-block; margin-top:2px; }

    .msg img.preview { max-width: 260px; border-radius: 8px; margin-top:4px; display:block; }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="row">
      <div class="pill" id="status">booting…</div>
      <div class="pill" id="chan">channel: —</div>
      <div class="pill" id="user">user: —</div>
    </div>
    <div class="row">
      <button id="clearLog" class="btn">Clear log</button>
      <button id="reconnect" class="btn">Reconnect</button>
    </div>
  </header>

  <div id="log"></div>

  <div class="composer">
    <textarea id="text" class="input" placeholder="type a message, Enter to send" autocomplete="off"></textarea>
    <div class="toolbar">
      <input id="file" type="file" multiple />
      <button id="send" class="btn">Send</button>
    </div>
  </div>
  <div class="filelist" id="queuedFiles"></div>
</div>

<script type="module">


async function setFavicon(dataUri) {
  // remove old favicons if any
  document.querySelectorAll("link[rel~='icon']").forEach(el => el.remove());

  // create new link
  const link = document.createElement("link");
  link.rel = "icon";
  link.href = dataUri;

  document.head.appendChild(link);
}

(async () => {
  const dataUri = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAEI0lEQVR4AeyasW4TQRCGd09nRCACQUcFHRR01EihQkoseIXQUNAhHFEhQQdxhMIbhDoNCCdUKCDxAJEokGjIC4CEKFBsJ8tt5ItP9p1n77yeG9/9kUa3uRnvzH1fNomcBAofoghAiCgdSkEIhAgjIGwcnBAIEUZA2Dg4IRAijICwcXKfkEdmabHVW3nZ6ja/r3VXfiLGGVg2lpFlldd3LiGtXvPP+f7iX630U63VDaX1NcQ4A8tGR4wsK8ssjxRnIWu9ptFKXXDaHEWnBCwzy+70BrFwErLWb/4m9kGaIODKkBRy8n3QqEtEP6QpAhHDE5ZEHSlkoX/uGbEH0o4EXFiSQgIV3EvvZ/aVNluIFAbK7Kcxy2Y5rCaFKGPODssTK6322+HOA8Q4AxWxSZAaLrNYDivwbm+ChYglfUJEjFmfISBEmGsIgZDCBGrxQpwQYZohBEKEERA2Dk5IHYXYt5+rEBzucEI4KOfoASE5YHGUQggH5Rw9ICQHLI5SCOGgnKMHixDTV3dmHUrpJRu2T3y167SI86NXW5t2z963oRg+WIRsLHQ+zzrajQ9fbNg+8dWu0yLOj15tbdo9e98Ggw/8gYoDcp4eLCckz0B1r4UQYV8BEAIhwggIG4flhLT+NZeqEBzuWIToUO1VISojhONBhPUoPA7LCSk8XQ1fCCHCpEMIhAgjIGwclhPSbnR0FYLDHYsQjgepSg8IEWYSQiBEGAFh4+CEzJMQYbPWYhyWE1L2v5G2es29ebHJImReYEiYE0IkWEjMACEJGBKWECLBQmIGCEnAkLBkEaK1WS0zlD7elADbZQYWIevhztsyYyPcfe8CQ0INixAJDzovM5QgZF7QlDMnhJTDPbMrhGSiKScBIeVwz+wKIZloyklASDncM7tCSCaachIQUg73zK4zEdI6XL5f9h+lyuyvjF5NJR6or6n3Eze9C2kdrtzUQfAu0QPLAQFt9NZgmXkJMjMFEk/M8lUd6G8FXjr1S+Zhg/VG5xM1pzchj83dy0E/OKAa1jV/FB5fd3n2wKWIqnlobjXCfuMXVVfXfAT59mu9+8Pl+aNal7LJNRf7V7qTK+qZNUp9PAgXwleNDvnDPCY0tRD720y8Wdo1Gup5Ff7zvcgzbDQ6y9t6+yiNS9a9qYS4yIiGepHVHPfHCRQXkvW79qCHPRmQMYCR41JcyIQmkDEBDpHyLgQyCOJE2qsQyCBoO6S9CammDAeCnku8CIEMf1amFgIZ/mTYnaYSAhkWod8oLAQy/IqIdyskBDJifP6vuYVAhn8JyR1zCYGMJLrZrJ2FQMZsBIzu6iQEMkaxze5zByF6E+/a+hUwaTdSSPtM582kDZDzS4AU4rcddqMIQAhFiDkPIczAqXYQQhFizkMIM3CqHYRQhJjzEMIMnGr3HwAA//+CZvSpAAAABklEQVQDAEs5EiMLXmvsAAAAAElFTkSuQmCC"; // your data URI
  await setFavicon(dataUri);
})();

  const $ = (s)=>document.querySelector(s);
  const logEl = $('#log');
  const statusEl = $('#status');
  const chanEl = $('#chan');
  const userEl = $('#user');
  const textEl = $('#text');
  const sendBtn = $('#send');
  const fileInp = $('#file');
  const queuedFilesEl = $('#queuedFiles');
  const clearBtn = $('#clearLog');
  const reconnectBtn = $('#reconnect');

  // placeholders from external JSON
  let ICONS = { none:"", onrror:"" };
  fetch("https://drmineword.github.io/funterminal/images.json")
    .then(r=>r.json()).then(j=>ICONS=j).catch(()=>{});

  const MAX_LOG_LINES = 500; // trim old messages

  const ui = {
    line(msg, cls='msg'){
      const d = document.createElement('div');
      d.className = `line ${cls}`;
      d.textContent = msg;
      logEl.appendChild(d);
      trimLog();
      logEl.scrollTop = logEl.scrollHeight;
      return d;
    },
    sys(msg){ return this.line(`[system] ${msg}`, 'sys'); },
    err(msg){ return this.line(`[error] ${msg}`, 'err'); },
    warn(msg){ return this.line(`[warn] ${msg}`, 'warn'); },
    msgElement(msg){
      const container = document.createElement('div');
      container.className = 'line msg';

      const icon = document.createElement('img');
      icon.className = 'icon';
      icon.src = msg.user_icon || ICONS.none;
      icon.onerror = ()=>{ icon.src = ICONS.onrror; };
      container.appendChild(icon);

      const header = document.createElement('div');
      header.className = 'msg-header';
      const when = shortTime(msg.timestamp);
      header.textContent = `${msg.username || 'user'} ${when? '('+when+')':''}`;
      container.appendChild(header);

      const body = document.createElement('div');
      body.className = 'msg-body';
      renderContent(msg.content||'', body);

      // render file links
      if (Array.isArray(msg.files)) {
        msg.files.forEach(f=>{
          const a = document.createElement('a');
          a.className = 'dl';
          a.textContent = `[${f.name} (${formatSize(f.size)}) download]`;
          if (f.data) {
            try {
              const base64 = (f.data||'').split(',')[1]||'';
              const bytes = Uint8Array.from(atob(base64), c=>c.charCodeAt(0));
              const blob = new Blob([bytes], { type: f.mime||'application/octet-stream' });
              a.href = URL.createObjectURL(blob);
              a.download = f.name || 'file';
            } catch {}
          }
          body.appendChild(document.createElement("br"));
          body.appendChild(a);
        });
      }

      container.appendChild(body);

      logEl.appendChild(container);
      trimLog();
      logEl.scrollTop = logEl.scrollHeight;
      return container;
    },
    fileBadge({name,size}){
      const span = document.createElement('span');
      span.className = 'filepill';
      span.textContent = `${name} (${formatSize(size)})`;
      return span;
    }
  };

 const shortTime = (ts) => {
  if (!ts) return '';
  const d = new Date(ts);

  const pad = (n) => String(n).padStart(2, '0');
  const hhmmss = `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;

  const now = new Date();

  // Compare only the year, month, and date
  const isToday = d.getFullYear() === now.getFullYear() &&
                  d.getMonth() === now.getMonth() &&
                  d.getDate() === now.getDate();

  const yesterday = new Date(now);
  yesterday.setDate(now.getDate() - 1);

  const isYesterday = d.getFullYear() === yesterday.getFullYear() &&
                      d.getMonth() === yesterday.getMonth() &&
                      d.getDate() === yesterday.getDate();

  if (isToday) return `Today at: ${hhmmss}`;
  if (isYesterday) return `Yesterday at: ${hhmmss}`;

  return `${pad(d.getDate())}-${pad(d.getMonth() + 1)}-${d.getFullYear()} ${hhmmss}`;
};



  function renderContent(text, el){
const regex = /!\[\]\(([^\s)]+)\)/g;
    let lastIndex = 0, match;
    while ((match = regex.exec(text))){
      if (match.index > lastIndex){
        el.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
      }
      const img = document.createElement('img');
      img.className = 'preview';
      img.src = match[1];
      img.alt = 'image';
      img.onerror=()=>{ img.style.display='none'; };
      el.appendChild(img);
      lastIndex = regex.lastIndex;
    }
    if (lastIndex < text.length){
      el.appendChild(document.createTextNode(text.slice(lastIndex)));
    }
  }

  const formatSize = (n)=>{
    if (n==null) return '?';
    const u=['B','KB','MB','GB']; let i=0; while(n>=1024 && i<u.length-1){n/=1024;i++;}
    return `${n.toFixed( (i?1:0) )} ${u[i]}`;
  };

  function fileToBase64(file){
    return new Promise((resolve,reject)=>{
      const reader = new FileReader();
      reader.onload = ()=>resolve(reader.result);
      reader.onerror = e=>reject(e);
      reader.readAsDataURL(file);
    });
  }

  function trimLog(){
    while (logEl.children.length > MAX_LOG_LINES) {
      logEl.removeChild(logEl.firstChild);
    }
  }

  // ---------- state ----------
  let auth = null; 
  let client = null; 
  let channel = null; 
  let channelName = 'main';
  let realtimeHash = null;
  let sendingCooldown = false;
  const seenMsgIds = new Set();
  let historyCursor = null;
  let msgLimit = 50;

  const params = new URLSearchParams(location.search);
  if (params.get("msglimit")) {
    const v = parseInt(params.get("msglimit"),10);
    if (!isNaN(v) && v>0) msgLimit = v;
  }

  function epHistory(){
    return `${auth.baseurl}/${auth.subpart}/chat/history?channel=${encodeURIComponent(channelName)}&user_id=${encodeURIComponent(auth.user_id)}&limit=${msgLimit}${historyCursor?`&before=${encodeURIComponent(historyCursor)}`:''}`;
  }
  function epSend(){
    return `${auth.baseurl}/${auth.subpart}/chat/send?user_id=${encodeURIComponent(auth.user_id)}`;
  }

  // ---------- bootstrap ----------
  async function boot(){
    try{
      status('booting');
      const authParam = params.get('auth');
      if (!authParam) throw new Error('No auth parameter');
      auth = JSON.parse(atob(authParam));
      if (!auth.user_id || !auth.baseurl || !auth.subpart) throw new Error('Invalid auth payload');
      const userEl = document.querySelector('#user'); // or whatever your element is
const userId = auth.user_id;

const maskedUserId = userId.slice(0, 5) + '#'.repeat(Math.max(0, userId.length - 5));

userEl.textContent = `user: ${maskedUserId}`;


      const authUrl = `${auth.baseurl}/${auth.subpart}/auth?user_id=${encodeURIComponent(auth.user_id)}`;
      ui.sys(`authenticating…`);
      const res = await fetch(authUrl);
      const data = await res.json();
      if (data.info_code !== 200) {
        if (data.info_code === 429) throw new Error(`Banned: ${data.msg}`);
        throw new Error(data.msg||'Auth failed');
      }

      const wsScript = (data.script||[]).find(s=>s.type==='xano_websocket');
      const wsInfo = data.websocket || data;
      realtimeHash = wsInfo.hash;
      channelName = wsInfo.name || 'main';
      chanEl.textContent = `channel: ${channelName}`;

      if (!wsScript?.url) throw new Error('Missing websocket script URL');
      ui.sys('loading websocket client…');
      await import(wsScript.url);

      ui.sys('connecting websocket…');
      client = new XanoClient({ instanceBaseUrl: auth.baseurl, realtimeConnectionHash: realtimeHash });
      channel = client.channel(channelName);
      channel.on(handleEvent);
      channel.join?.({ history: true, presence: false }).catch(()=>{});
      status('connected');
      ui.sys('connected');
      await fetchAndRenderHistory();

    }catch(err){
      status('error');
      ui.err(err.message||String(err));
    }
  }

  function status(s){
    const map = { connected: ['✅ Connected', 'var(--accent)'], booting: ['⏳ Booting', 'var(--muted)'], error: ['❌ Error', 'var(--error)'] };
    const [label,color] = map[s] || [s, 'var(--muted)'];
    statusEl.textContent = label; 
    statusEl.style.color = color;
  }

  async function fetchAndRenderHistory(){
    try{
      const url = epHistory();
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error(`history ${r.status}`);
      const j = await r.json();
      const msgs = j.messages||[];
      if (msgs.length) ui.sys(`[history] ${msgs.length} message(s)`);
      msgs.forEach(renderMessage);
      historyCursor = msgs.length ? msgs[0].__msg_id : historyCursor;
    }catch(e){ ui.warn(`history load failed: ${e.message}`); }
  }

  function handleEvent(action){
    const data = action?.payload?.data;
    if (!data) return;
    if (Array.isArray(data)) { data.forEach(renderMessage); } else { renderMessage(data); }
  }

  function renderMessage(msg){
    if (msg.__msg_id && seenMsgIds.has(msg.__msg_id)) return;
    ui.msgElement(msg);
    if (msg.__msg_id) seenMsgIds.add(msg.__msg_id);
  }

  async function sendMessage(){
    if (sendingCooldown) { ui.warn('slow down (1 msg/sec)'); return; }
    const content = textEl.value.trim();
    if (!content && fileInp.files.length===0) return;
    const files = [];
    for (const f of fileInp.files){
      const data = await fileToBase64(f);
      files.push({ name: f.name, size: f.size, mime: f.type, data });
    }
    const payload = { user_id: auth.user_id, channel: channelName, content, files };
    try{
      sendingCooldown = true; setTimeout(()=>sendingCooldown=false, 1000);
      const r = await fetch(epSend(), { method:'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
      if (r.status === 429){ 
        const txt = await r.text().catch(()=>null);
        ui.warn(`rate limited (429) ${txt||''}`);
        return; 
      }
      if (!r.ok){ 
        let extra="";
        try{ extra = JSON.stringify(await r.json()); }catch{}
        ui.err(`send failed ${r.status} ${extra}`);
        return; 
      }
      await r.json().catch(()=>({}));
      textEl.value=''; fileInp.value='';
    }catch(err){ ui.err('network error sending'); }
  }

  // ---------- UI events ----------
  textEl.addEventListener('keydown', (e)=>{ 
    if (e.key==='Enter' && !e.shiftKey){ 
      e.preventDefault(); sendMessage(); 
    }
  });
  textEl.addEventListener('input', ()=>{
    textEl.style.height = "auto";
    textEl.style.height = textEl.scrollHeight+"px";
  });
  sendBtn.addEventListener('click', sendMessage);
  clearBtn.addEventListener('click', ()=>{ logEl.innerHTML=''; ui.sys('log cleared'); });
  reconnectBtn.addEventListener('click', ()=>{ location.reload(); });
  fileInp.addEventListener('change', ()=>{
    queuedFilesEl.innerHTML = '';
    for (const f of fileInp.files){ queuedFilesEl.appendChild(ui.fileBadge({name:f.name,size:f.size})); }
  });

  boot();
</script>
</body>
</html>
