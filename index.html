<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Terminal Chatroom</title>
  <style>
    :root {
      --bg: #0b0e0c;
      --panel: #111511;
      --text: #c8facc;
      --muted: #7ecf87;
      --error: #ff6b6b;
      --warn: #ffd166;
      --accent: #3ad13a;
      --border: #1d2a1f;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 16px; background: var(--bg); color: var(--text);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    .wrap { max-width: 980px; margin: 0 auto; display: grid; gap: 12px; }
    header { display:flex; gap:12px; align-items:center; justify-content:space-between; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .pill { padding:6px 10px; border:1px solid var(--border); background: var(--panel); border-radius: 999px; color: var(--muted); }
    .btn { cursor:pointer; border:1px solid var(--border); background: var(--panel); color: var(--text); border-radius:10px; padding:6px 10px; }
    .btn:disabled { opacity: .5; cursor:not-allowed; }
    .danger { color: var(--error); border-color:#442222; }

    #log {
      background: #0d120e; border: 1px solid var(--border); border-radius: 12px; padding: 10px; height: 420px; overflow-y: auto;
      white-space: normal; line-height: 1.35; box-shadow: 0 0 0 1px #0c140e inset;
    }
    .line { padding: 6px 0; }
    .sys { color: var(--muted); }
    .err { color: var(--error); }
    .warn { color: var(--warn); }
    .msg { color: var(--text); display:grid; grid-template-columns:30px auto; gap:6px; align-items:flex-start; }
    .msg img.icon { width:24px; height:24px; border-radius:50%; grid-row: span 2; }
    .msg-header { font-size: 13px; color: var(--muted); }
    .msg-body { margin-top:2px; white-space: pre-wrap; }

    .composer { display:grid; grid-template-columns: 1fr auto; gap:8px; }
    .input { width: 100%; padding:10px; border-radius:10px; border:1px solid var(--border); background: var(--panel); color: var(--text); }
    .toolbar { display:flex; gap:8px; align-items:center; }
    .filelist { display:flex; gap:6px; flex-wrap:wrap; }
    .filepill { border:1px solid var(--border); background:#0e1511; padding:4px 8px; border-radius:999px; font-size:12px; }
    a.dl { color:#c7e9ff; text-decoration: underline; cursor:pointer; display:inline-block; margin-top:2px; }

    .legend { font-size: 12px; color: var(--muted); }
    .sectionTitle { color:#a1f0a8; margin: 8px 0 4px; }
    .msg img.preview { max-width: 260px; border-radius: 8px; margin-top:4px; display:block; }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="row">
      <div class="pill" id="status">booting…</div>
      <div class="pill" id="chan">channel: —</div>
      <div class="pill" id="user">user: —</div>
    </div>
    <div class="row">
      <button id="clearLog" class="btn">Clear log</button>
      <button id="reconnect" class="btn">Reconnect</button>
    </div>
  </header>

  <div class="sectionTitle">[history]</div>
  <div id="log"></div>

  <div class="composer">
    <input id="text" class="input" placeholder="type a message, Enter to send" autocomplete="off" />
    <div class="toolbar">
      <input id="file" type="file" multiple />
      <button id="send" class="btn">Send</button>
    </div>
  </div>
  <div class="legend">Files are sent as base64. Messages throttle at 1 msg/sec. Pending messages remain until echoed by websocket. 429 keeps pending.</div>
  <div class="filelist" id="queuedFiles"></div>
</div>

<script type="module">
  const $ = (s)=>document.querySelector(s);
  const logEl = $('#log');
  const statusEl = $('#status');
  const chanEl = $('#chan');
  const userEl = $('#user');
  const textEl = $('#text');
  const sendBtn = $('#send');
  const fileInp = $('#file');
  const queuedFilesEl = $('#queuedFiles');
  const clearBtn = $('#clearLog');
  const reconnectBtn = $('#reconnect');

  // placeholders from external JSON
  let ICONS = { none:"", onrror:"" };
  fetch("https://drmineword.github.io/images.json")
    .then(r=>r.json()).then(j=>ICONS=j).catch(()=>{});

  // ---------- helpers ----------
  const ui = {
    line(msg, cls='msg'){
      const d = document.createElement('div');
      d.className = `line ${cls}`;
      d.textContent = msg;
      logEl.appendChild(d);
      logEl.scrollTop = logEl.scrollHeight;
      return d;
    },
    sys(msg){ return this.line(`[system] ${msg}`, 'sys'); },
    err(msg){ return this.line(`[error] ${msg}`, 'err'); },
    warn(msg){ return this.line(`[warn] ${msg}`, 'warn'); },
    msgElement(msg){
      const container = document.createElement('div');
      container.className = 'line msg';

      // icon
      const icon = document.createElement('img');
      icon.className = 'icon';
      icon.src = msg.user_icon || ICONS.none;
      icon.onerror = ()=>{ icon.src = ICONS.onrror; };
      container.appendChild(icon);

      // header
      const header = document.createElement('div');
      header.className = 'msg-header';
      const when = shortTime(msg.timestamp);
      header.textContent = `${msg.username || 'user'} ${when? '('+when+')':''}`;
      container.appendChild(header);

      // body
      const body = document.createElement('div');
      body.className = 'msg-body';
      renderContent(msg.content||'', body);
      container.appendChild(body);

      logEl.appendChild(container);
      logEl.scrollTop = logEl.scrollHeight;
      return container;
    },
    fileBadge({name,size}){
      const span = document.createElement('span');
      span.className = 'filepill';
      span.textContent = `${name} (${formatSize(size)})`;
      return span;
    }
  };

  const shortTime = (ts)=>{
    if (!ts) return '';
    const d = new Date(ts);
    return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  };

  function renderContent(text, el){
    const regex = /!\[\]\((https?:\/\/[^\s)]+)\)/g;
    let lastIndex = 0, match;
    while ((match = regex.exec(text))){
      if (match.index > lastIndex){
        el.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
      }
      const img = document.createElement('img');
      img.className = 'preview';
      img.src = match[1];
      img.alt = 'image';
      img.onerror=()=>{ img.style.display='none'; };
      el.appendChild(img);
      lastIndex = regex.lastIndex;
    }
    if (lastIndex < text.length){
      el.appendChild(document.createTextNode(text.slice(lastIndex)));
    }
  }

  const formatSize = (n)=>{
    if (n==null) return '?';
    const u=['B','KB','MB','GB']; let i=0; while(n>=1024 && i<u.length-1){n/=1024;i++;}
    return `${n.toFixed( (i?1:0) )} ${u[i]}`;
  };

  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

  function hashContent(str){
    let h = 2166136261 >>> 0;
    for (let i=0;i<str.length;i++){ h ^= str.charCodeAt(i); h = Math.imul(h, 16777619); }
    return (h>>>0).toString(16);
  }

  async function fileToBase64(file){
    const buf = await file.arrayBuffer();
    const b64 = btoa(String.fromCharCode(...new Uint8Array(buf)));
    return `data:${file.type||'application/octet-stream'};base64,${b64}`;
  }

  // ---------- state ----------
  let auth = null; 
  let client = null; 
  let channel = null; 
  let channelName = 'main';
  let realtimeHash = null;
  let sendingCooldown = false;
  const seenMsgIds = new Set();
  let historyCursor = null;

  function epHistory(){
    return `${auth.baseurl}/${auth.subpart}/chat/history?channel=${encodeURIComponent(channelName)}&limit=50${historyCursor?`&before=${encodeURIComponent(historyCursor)}`:''}`;
  }
  function epSend(){
    return `${auth.baseurl}/${auth.subpart}/chat/send`;
  }

  // ---------- bootstrap ----------
  async function boot(){
    try{
      status('booting');
      const params = new URLSearchParams(location.search);
      const authParam = params.get('auth');
      if (!authParam) throw new Error('No auth parameter');
      auth = JSON.parse(atob(authParam));
      if (!auth.user_id || !auth.baseurl || !auth.subpart) throw new Error('Invalid auth payload');
      userEl.textContent = `user: ${auth.user_id}`;

      const authUrl = `${auth.baseurl}/${auth.subpart}/auth?user_id=${encodeURIComponent(auth.user_id)}`;
      ui.sys(`authenticating…`);
      const res = await fetch(authUrl);
      const data = await res.json();
      if (data.info_code !== 200) {
        if (data.info_code === 429) throw new Error(`Banned: ${data.msg}`);
        throw new Error(data.msg||'Auth failed');
      }

      const wsScript = (data.script||[]).find(s=>s.type==='xano_websocket');
      const wsInfo = data.websocket || data;
      realtimeHash = wsInfo.hash;
      channelName = wsInfo.name || 'main';
      chanEl.textContent = `channel: ${channelName}`;

      if (!wsScript?.url) throw new Error('Missing websocket script URL');
      ui.sys('loading websocket client…');
      await import(wsScript.url);

      ui.sys('connecting websocket…');
      client = new XanoClient({ instanceBaseUrl: auth.baseurl, realtimeConnectionHash: realtimeHash });
      channel = client.channel(channelName);
      channel.on(handleEvent);
      channel.join?.({ history: true, presence: false }).catch(()=>{});
      status('connected');
      ui.sys('connected');
      await fetchAndRenderHistory();

    }catch(err){
      status('error');
      ui.err(err.message||String(err));
    }
  }

  function status(s){
    const map = { connected: ['✅ Connected', 'var(--accent)'], booting: ['⏳ Booting', 'var(--muted)'], error: ['❌ Error', 'var(--error)'] };
    const [label,color] = map[s] || [s, 'var(--muted)'];
    statusEl.textContent = label; 
    statusEl.style.color = color;
  }

  async function fetchAndRenderHistory(){
    try{
      const url = epHistory();
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error(`history ${r.status}`);
      const j = await r.json();
      const msgs = j.messages||[];
      if (msgs.length) ui.sys(`[history] ${msgs.length} message(s)`);
      msgs.forEach(renderMessage);
      historyCursor = msgs.length ? msgs[0].__msg_id : historyCursor;
    }catch(e){ ui.warn(`history load failed: ${e.message}`); }
  }

  function handleEvent(action){
    const data = action?.payload?.data;
    if (!data) return;
    if (Array.isArray(data)) { data.forEach(renderMessage); } else { renderMessage(data); }
  }

  function renderMessage(msg){
    if (msg.__msg_id && seenMsgIds.has(msg.__msg_id)) return;
    ui.msgElement(msg);
    if (msg.__msg_id) seenMsgIds.add(msg.__msg_id);
  }

  async function sendMessage(){
    if (sendingCooldown) { ui.warn('slow down (1 msg/sec)'); return; }
    const content = textEl.value.trim();
    if (!content && fileInp.files.length===0) return;
    const files = [];
    for (const f of fileInp.files){
      const data = await fileToBase64(f);
      files.push({ name: f.name, size: f.size, mime: f.type, data });
    }
    const payload = { user_id: auth.user_id, channel: channelName, content, files };
    try{
      sendingCooldown = true; setTimeout(()=>sendingCooldown=false, 1000);
      const r = await fetch(epSend(), { method:'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
      if (r.status === 429){ ui.warn('rate limited (429) — will confirm when echoed'); return; }
      if (!r.ok){ ui.err(`send failed ${r.status}`); return; }
      await r.json().catch(()=>({}));
      textEl.value=''; fileInp.value='';
    }catch(err){ ui.err('network error sending'); }
  }

  textEl.addEventListener('keydown', (e)=>{ if (e.key==='Enter') sendMessage(); });
  sendBtn.addEventListener('click', sendMessage);
  clearBtn.addEventListener('click', ()=>{ logEl.innerHTML=''; ui.sys('log cleared'); });
  reconnectBtn.addEventListener('click', ()=>{ location.reload(); });
  fileInp.addEventListener('change', ()=>{
    queuedFilesEl.innerHTML = '';
    for (const f of fileInp.files){ queuedFilesEl.appendChild(ui.fileBadge({name:f.name,size:f.size})); }
  });

  boot();
</script>
</body>
</html>
